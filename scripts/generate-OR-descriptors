#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Generate valid and signed descriptors for mocked Tor relays or bridges.

.. note:: This application uses the CFFI_ version of PyNaCl_ to emulate the
    following curvecp_ commands (the ``curvecp*`` commands require
    libchloride_, which is therefore also required):

        $ curvecpmakekey ntor-key
        $ curvecpprintkey ntor-key > ntor-key.hex
        $ python -c 'import binascii, sys; \
            key_hex=open('./ntor-key.hex','rb').read();\
            key_b64=binascii.b2a_base64(binascii.unhexlify(key_hex));\
            sys.stdout.write(key_b64);'

    .. _CFFI: https://cffi.readthedocs.org
    .. _PyNaCl: https://github.com/pyca/pynacl
    .. _curvecp: http://curvecp.org/
    .. _libchloride: https://github.com/jedisct1/libchloride

.. authors:: Isis Lovecruft <isis@torproject.org> 0xA3ADB67A2CDB8B35
             Matthew Finkel <sysrqb@torproject.org>
.. licence:: see LICENSE file for licensing details
.. copyright:: (c) 2013-2014 The Tor Project, Inc.
               (c) 2013-2014 Isis Lovecruft
               (c) 2013-2014 Matthew Finkel
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import binascii
import hashlib
import ipaddr
import logging
import math
import os
import sys
import random
import re
import traceback

from datetime import datetime
from codecs   import open as open

try:
    import OpenSSL.crypto
except (ImportError, NameError) as error:
    print("This script requires pyOpenSSL>=0.13.0")
    raise SystemExit(error.message)

from leekspin import const
from leekspin import crypto
from leekspin import nicknames
from leekspin import ntor
from leekspin import rsa
from leekspin import tls
from leekspin import torversions
from leekspin import util

logging.getLogger('leekspin').setLevel(10)

#: If the pynacl was found by :attr:`leekspin.ntor.nacl`.
nacl = ntor.nacl


def signDescriptorDigest(key, descriptorDigest, digest='sha1'):
    """Ugh...I hate OpenSSL.

    The extra-info-digest is a SHA-1 hash digest of the extrainfo document,
    that is, the entire extrainfo descriptor up until the end of the
    'router-signature' line and including the newline, but not the actual
    signature.

    The signature at the end of the extra-info descriptor is a signature of
    the above extra-info-digest. This signature is appended to the end of the
    extrainfo document, and the extra-info-digest is added to the
    'extra-info-digest' line of the [bridge-]server-descriptor.

    The first one of these was created with a raw digest, the second with a
    hexdigest. They both encode the the 'sha1' digest type if you check the
    `-asnparse` output (instead of `-raw -hexdump`).

    .. command:: openssl rsautl -inkey eiprivkey -verify -in eisig1 -raw -hexdump
      |
      | 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30   .............0!0
      | 0060 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 42 25 41 fb   ...+........B%A.
      | 0070 - 82 ef 11 f4 5f 2c 95 53-67 2d bb fe 7f c2 34 7f   ...._,.Sg-....4.

    .. command:: openssl rsautl -inkey eiprivkey -verify -in eisig2 -raw -hexdump
      |
      | 0000 - 00 01 ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0010 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0020 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0030 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0040 - ff ff ff ff ff ff ff ff-ff ff ff ff ff ff ff ff   ................
      | 0050 - ff ff ff ff ff ff ff ff-ff ff ff ff 00 30 21 30   .............0!0
      | 0060 - 09 06 05 2b 0e 03 02 1a-05 00 04 14 44 30 ab 90   ...+........D0..
      | 0070 - 93 d1 08 21 df 87 c2 39-2a 04 1c a5 bb 34 44 cd   ...!...9*....4D.

    .. todo:: See the RSA PKCS_ Standard v2.2 for why this function is totally
       wrong.

    .. _PKCS: http://www.emc.com/collateral/white-papers/h11300-pkcs-1v2-2-rsa-cryptography-standard-wp.pdf

    :type key: :class:`OpenSSL.crypto.PKey`
    :param key: An RSA private key.
    :param string descriptorDigest: The raw SHA-1 digest of any descriptor
        document.
    :param string digest: The digest to use. (default: 'sha1')
    """
    sig = binascii.b2a_base64(OpenSSL.crypto.sign(key, descriptorDigest,
                                                  digest))
    sigCopy = sig
    originalLength = len(sigCopy.replace('\n', ''))

    # Only put 64 bytes of the base64 signature per line:
    sigSplit = []
    while len(sig) > 0:
        sigSplit.append(sig[:64])
        sig = sig[64:]
    sigFormatted = '\n'.join(sigSplit)

    sigFormattedCopy = sigFormatted
    formattedLength = len(sigFormattedCopy.replace('\n', ''))

    if originalLength != formattedLength:
        print("WARNING: signDescriptorDocument(): %s"
              % "possible bad reformatting for signature.")
        print("DEBUG: signDescriptorDocument(): original=%d formatted=%d"
              % (originalLength, formattedLength))
        print("DEBUG: original:\n%s\nformatted:\n%s"
              % (sigCopy, sigFormatted))

    sigWithHeaders = const.TOR_BEGIN_SIG + '\n' \
                     + sigFormatted \
                     + const.TOR_END_SIG + '\n'
    return sigWithHeaders

def generateDescriptors():
    """Create keys, certs, signatures, documents and descriptors for an OR.

    :returns:
        A 3-tuple of strings:
          - a ``@type [bridge-]extra-info`` descriptor,
          - a ``@type [bridge-]server-descriptor``, and
          - a ``@type network-status`` document
       for a mock Tor relay/bridge.
    """
    ipv4 = util.randomIPv4()
    ipv6 = util.randomIPv6()
    port = util.randomPort()

    nick = nicknames.generateNickname()
    vers = torversions.getRandomVersion()
    uptime = int(random.randint(1800, 63072000))
    bandwidth = makeBandwidthLine()
    timestamp = util.makeTimeStamp(variation=True, period=36)
    protocols = makeProtocolsLine(vers)

    SIDSKey, SIDPCert, (onionkey, signingkey) = makeOnionKeys()
    idkey_private = tls.getPrivateKey(SIDSKey)
    idkey_digest = hashlib.sha1(idkey_private).digest()

    idkey_public = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_ASN1,
                                                  SIDPCert.get_pubkey())
    idkey_public = re.sub(const.OPENSSL_BEGIN_KEY, '', idkey_public)
    idkey_public = re.sub(const.OPENSSL_END_KEY, '', idkey_public)
    idkey_public = idkey_public.strip()

    ident_digest = hashlib.sha1(idkey_public).digest()
    fingerprint = hashlib.sha1(idkey_public).hexdigest().upper()
    fpr = crypto.convertToSpaceyFingerprint(fingerprint)

    extrainfo_document = generateExtraInfo(nick, fingerprint,
                                           timestamp, ipv4, port)
    extrainfo_digest = hashlib.sha1(extrainfo_document).digest()
    extrainfo_hexdigest = hashlib.sha1(extrainfo_document).hexdigest().upper()
    extrainfo_sig = signDescriptorDigest(SIDSKey, extrainfo_digest)
    extrainfo_desc = extrainfo_document + extrainfo_sig

    server = []
    server.append("@purpose bridge")
    server.append("router %s %s %s 0 0" % (nick, ipv4, port))
    server.append("or-address [%s]:%s" % (ipv6, port))
    server.append("platform Tor %s on Linux" % vers)
    server.append("%s\npublished %s" % (protocols, timestamp))
    server.append("%s" % makeFingerprintLine(fingerprint, vers))
    server.append("uptime %s\n%s" % (uptime, bandwidth))
    server.append("%s" % makeExtraInfoDigestLine(extrainfo_hexdigest, vers))
    server.append("%s%s%s" % (onionkey, signingkey, makeHSDirLine(vers)))
    server.append("contact Somebody <somebody@example.com>")
    if nacl is not None:
        ntorkey = ntor.getNTORPublicKey()
        if ntorkey is not None:
            server.append("ntor-onion-key %s" % ntorkey)
    server.append("reject *:*\nrouter-signature\n")
    server_desc = '\n'.join(server)

    server_desc_digest = hashlib.sha1(server_desc).digest()
    netstatus_desc = generateNetstatus(nick, ident_digest, server_desc_digest,
                                       timestamp, ipv4, port, ipv6=ipv6,
                                       bandwidth_line=bandwidth)
    server_desc += signDescriptorDigest(SIDSKey, server_desc_digest)
    return extrainfo_desc, server_desc, netstatus_desc

def writeDescToFile(filename, descriptors):
    """Open ``filename`` and write a string containing descriptors into it.

    :param string filename: The name of the file to write to.
    :param string descriptors: A giant string containing descriptors,
        newlines, formatting, whatever is necessary to make it look like a
        file tor would generate.
    """
    encoding = sys.getfilesystemencoding()
    descript = descriptors.encode(encoding, 'replace')
    try:
        with open(filename, 'wb', encoding=encoding, errors='replace') as fh:
            fh.write(descript)
            fh.flush()
    except (IOError, OSError) as err:
        print("Failure while attempting to write descriptors to file '%s': %s"
              % (filename, err.message))

def create(count):
    """Generate all types of descriptors and write them to files.

    :param integer count: How many sets of descriptors to generate, i.e. how
        many mock bridges/relays to create.
    """
    if nacl is None:
        logging.warn("WARNING: Can't import PyNaCl. NTOR key generation is disabled.")
    print("Generating %d bridge descriptors..." % int(count))
    logging.info("Generated router nicknames:")

    server_descriptors    = list()
    netstatus_consensus   = list()
    extrainfo_descriptors = list()
    try:
        for i in xrange(int(count)):
            try:
                extrainfo, server, netstatus = generateDescriptors()
            except Exception as error:
                err, msg, tb = sys.exc_info()
                print(traceback.print_tb(tb))
                print(error)
            else:
                server_descriptors.append(server)
                netstatus_consensus.append(netstatus)
                extrainfo_descriptors.append(extrainfo)
    except KeyboardInterrupt as keyint:
        print("Received keyboard interrupt.")
        print("Stopping descriptor creation and exiting.")
        code = 1515
    finally:
        print("Writing descriptors to files...", end="")

        cached = "cached-extrainfo.new"
        descriptor_files = {
            "networkstatus-bridges": ''.join(netstatus_consensus),
            "bridge-descriptors": ''.join(server_descriptors),
            "cached-extrainfo.new": ''.join(extrainfo_descriptors)}

        if not os.path.isfile(cached):
            with open(cached, 'wb') as fh:
                fh.flush()
        if os.path.isfile(cached):
            os.rename(cached, "cached-extrainfo")

        for fn, giantstring in descriptor_files.items():
            writeDescToFile(fn, giantstring)
        print("Done.")
        code = 0
        sys.exit(code)

if __name__ == "__main__":
    try:
        parser = util.getArgParser()
        options = parser.parse_args()

        if options.verbose:
            logging.getLogger('leekspin').addHandler(logging.StreamHandler())
            logging.getLogger('leekspin').setLevel(10)
        elif options.quiet:
            print = lambda x: True
            logging.ignore(100)

        if options.version:
            print("gen_bridge_descriptors-%s" % parser.version)
            sys.exit(0)

        if options.descriptors and (options.descriptors > 0):
            create(options.descriptors)
        else:
            raise SystemExit(parser.format_help())

    except Exception as error:
        raise SystemExit(error)
