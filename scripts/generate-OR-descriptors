#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""Generate valid and signed descriptors for mocked Tor relays or bridges.

.. note:: This application uses the CFFI_ version of PyNaCl_ to emulate the
    following curvecp_ commands (the ``curvecp*`` commands require
    libchloride_, which is therefore also required):

        $ curvecpmakekey ntor-key
        $ curvecpprintkey ntor-key > ntor-key.hex
        $ python -c 'import binascii, sys; \
            key_hex=open('./ntor-key.hex','rb').read();\
            key_b64=binascii.b2a_base64(binascii.unhexlify(key_hex));\
            sys.stdout.write(key_b64);'

    .. _CFFI: https://cffi.readthedocs.org
    .. _PyNaCl: https://github.com/pyca/pynacl
    .. _curvecp: http://curvecp.org/
    .. _libchloride: https://github.com/jedisct1/libchloride

.. authors:: Isis Lovecruft <isis@torproject.org> 0xA3ADB67A2CDB8B35
             Matthew Finkel <sysrqb@torproject.org>
.. licence:: see LICENSE file for licensing details
.. copyright:: (c) 2013-2014 The Tor Project, Inc.
               (c) 2013-2014 Isis Lovecruft
               (c) 2013-2014 Matthew Finkel
"""

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import binascii
import hashlib
import ipaddr
import logging
import math
import os
import sys
import random
import re
import traceback

from datetime import datetime
from codecs   import open as open

try:
    import OpenSSL.crypto
except (ImportError, NameError) as error:
    print("This script requires pyOpenSSL>=0.13.0")
    raise SystemExit(error.message)

from leekspin import const
from leekspin import crypto
from leekspin import nicknames
from leekspin import ntor
from leekspin import rsa
from leekspin import tls
from leekspin import torversions
from leekspin import util

logging.getLogger('leekspin').setLevel(10)

#: If the pynacl was found by :attr:`leekspin.ntor.nacl`.
nacl = ntor.nacl


def generateDescriptors():
    """Create keys, certs, signatures, documents and descriptors for an OR.

    :returns:
        A 3-tuple of strings:
          - a ``@type [bridge-]extra-info`` descriptor,
          - a ``@type [bridge-]server-descriptor``, and
          - a ``@type network-status`` document
       for a mock Tor relay/bridge.
    """
    ipv4 = util.randomIPv4()
    ipv6 = util.randomIPv6()
    port = util.randomPort()

    nick = nicknames.generateNickname()
    vers = torversions.getRandomVersion()
    uptime = int(random.randint(1800, 63072000))
    bandwidth = makeBandwidthLine()
    timestamp = util.makeTimeStamp(variation=True, period=36)
    protocols = makeProtocolsLine(vers)

    SIDSKey, SIDPCert, (onionkey, signingkey) = makeOnionKeys()
    idkey_private = tls.getPrivateKey(SIDSKey)
    idkey_digest = hashlib.sha1(idkey_private).digest()

    idkey_public = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_ASN1,
                                                  SIDPCert.get_pubkey())
    idkey_public = re.sub(const.OPENSSL_BEGIN_KEY, '', idkey_public)
    idkey_public = re.sub(const.OPENSSL_END_KEY, '', idkey_public)
    idkey_public = idkey_public.strip()

    ident_digest = hashlib.sha1(idkey_public).digest()
    fingerprint = hashlib.sha1(idkey_public).hexdigest().upper()
    fpr = crypto.convertToSpaceyFingerprint(fingerprint)

    extrainfo_document = generateExtraInfo(nick, fingerprint,
                                           timestamp, ipv4, port)
    extrainfo_digest = hashlib.sha1(extrainfo_document).digest()
    extrainfo_hexdigest = hashlib.sha1(extrainfo_document).hexdigest().upper()
    extrainfo_sig = signDescriptorDigest(SIDSKey, extrainfo_digest)
    extrainfo_desc = extrainfo_document + extrainfo_sig

    server = []
    server.append("@purpose bridge")
    server.append("router %s %s %s 0 0" % (nick, ipv4, port))
    server.append("or-address [%s]:%s" % (ipv6, port))
    server.append("platform Tor %s on Linux" % vers)
    server.append("%s\npublished %s" % (protocols, timestamp))
    server.append("%s" % makeFingerprintLine(fingerprint, vers))
    server.append("uptime %s\n%s" % (uptime, bandwidth))
    server.append("%s" % makeExtraInfoDigestLine(extrainfo_hexdigest, vers))
    server.append("%s%s%s" % (onionkey, signingkey, makeHSDirLine(vers)))
    server.append("contact Somebody <somebody@example.com>")
    if nacl is not None:
        ntorkey = ntor.getNTORPublicKey()
        if ntorkey is not None:
            server.append("ntor-onion-key %s" % ntorkey)
    server.append("reject *:*\nrouter-signature\n")
    server_desc = '\n'.join(server)

    server_desc_digest = hashlib.sha1(server_desc).digest()
    netstatus_desc = generateNetstatus(nick, ident_digest, server_desc_digest,
                                       timestamp, ipv4, port, ipv6=ipv6,
                                       bandwidth_line=bandwidth)
    server_desc += signDescriptorDigest(SIDSKey, server_desc_digest)
    return extrainfo_desc, server_desc, netstatus_desc

def writeDescToFile(filename, descriptors):
    """Open ``filename`` and write a string containing descriptors into it.

    :param string filename: The name of the file to write to.
    :param string descriptors: A giant string containing descriptors,
        newlines, formatting, whatever is necessary to make it look like a
        file tor would generate.
    """
    encoding = sys.getfilesystemencoding()
    descript = descriptors.encode(encoding, 'replace')
    try:
        with open(filename, 'wb', encoding=encoding, errors='replace') as fh:
            fh.write(descript)
            fh.flush()
    except (IOError, OSError) as err:
        print("Failure while attempting to write descriptors to file '%s': %s"
              % (filename, err.message))

def create(count):
    """Generate all types of descriptors and write them to files.

    :param integer count: How many sets of descriptors to generate, i.e. how
        many mock bridges/relays to create.
    """
    if nacl is None:
        logging.warn("WARNING: Can't import PyNaCl. NTOR key generation is disabled.")
    print("Generating %d bridge descriptors..." % int(count))
    logging.info("Generated router nicknames:")

    server_descriptors    = list()
    netstatus_consensus   = list()
    extrainfo_descriptors = list()
    try:
        for i in xrange(int(count)):
            try:
                extrainfo, server, netstatus = generateDescriptors()
            except Exception as error:
                err, msg, tb = sys.exc_info()
                print(traceback.print_tb(tb))
                print(error)
            else:
                server_descriptors.append(server)
                netstatus_consensus.append(netstatus)
                extrainfo_descriptors.append(extrainfo)
    except KeyboardInterrupt as keyint:
        print("Received keyboard interrupt.")
        print("Stopping descriptor creation and exiting.")
        code = 1515
    finally:
        print("Writing descriptors to files...", end="")

        cached = "cached-extrainfo.new"
        descriptor_files = {
            "networkstatus-bridges": ''.join(netstatus_consensus),
            "bridge-descriptors": ''.join(server_descriptors),
            "cached-extrainfo.new": ''.join(extrainfo_descriptors)}

        if not os.path.isfile(cached):
            with open(cached, 'wb') as fh:
                fh.flush()
        if os.path.isfile(cached):
            os.rename(cached, "cached-extrainfo")

        for fn, giantstring in descriptor_files.items():
            writeDescToFile(fn, giantstring)
        print("Done.")
        code = 0
        sys.exit(code)

if __name__ == "__main__":
    try:
        parser = util.getArgParser()
        options = parser.parse_args()

        if options.verbose:
            logging.getLogger('leekspin').addHandler(logging.StreamHandler())
            logging.getLogger('leekspin').setLevel(10)
        elif options.quiet:
            print = lambda x: True
            logging.ignore(100)

        if options.version:
            print("gen_bridge_descriptors-%s" % parser.version)
            sys.exit(0)

        if options.descriptors and (options.descriptors > 0):
            create(options.descriptors)
        else:
            raise SystemExit(parser.format_help())

    except Exception as error:
        raise SystemExit(error)
